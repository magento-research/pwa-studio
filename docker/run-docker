#!/usr/bin/env bash

####################################################################################
#
#   Run this file from the root of the repository to build and run a PWA container
#
####################################################################################
OPTIND=1
EDITED_HOSTFILE="n"
CERT_TRUSTED="n"
IS_WINDOWS_MACHINE=false

# evaluate command line arguments
# run docker/run-docker -h for options
while getopts ":xwfch" opt; do
  case ${opt} in
    x ) IS_WINDOWS_MACHINE="n"
      ;;
    w ) IS_WINDOWS_MACHINE="y"
      ;;
    f ) EDITED_HOSTFILE="y"
      ;;
    c ) CERT_TRUSTED="y"
      ;;
    h ) echo -e "Usage: docker/run-docker [-x] [-w] [-f] [-c] [-h]"
         echo ""
         echo "     -x - You are on a Unix machine"
         echo "     -w - You are on a Windows machine"
         echo "     -f - Host file has been edited to contain the configured domain" 
         echo "     -c - ssl/tls certificate has been trusted for configured domain"
         echo "     -h - help"
         echo ""
         exit 1
      ;;
  esac
done

main () {
  if [ "$IS_WINDOWS_MACHINE" == false ]; then
    # capture whether the user is on a Windows machine for separate setup tasks
    read -p "Are you on a Windows machine? [y/n] " IS_WINDOWS_MACHINE
  fi

  message "Adding environment variables to .env for docker setup."
  ENVFILE=./.env
  cp ./docker/.env.docker $ENVFILE 
  . $ENVFILE

  DOMAIN=$PWA_STUDIO_PUBLIC_PATH
  HOSTMAP="127.0.0.1 $DOMAIN"

  if [ "$EDITED_HOSTFILE" == "n" ]; then
    add_domain_to_hostfile
  fi

  if [ "$CERT_TRUSTED" == "n" ]; then
    generate_certificate
  fi

  # By this point in the setup the host file should have the $DOMAIN and the certificate should be created and trusted
  if [ "$EDITED_HOSTFILE" == "y" ] && [ "$CERT_TRUSTED" == "y" ]; then
    start_docker
  else
    message "The host file does not include your domain and/or the certificate is not trusted.\nFollow the steps to edit your system host file and trust the ssl certificate.\nThe application will not run correctly without completing these steps."
    rm ./docker/certs/$DOMAIN.crt
    exit 1
  fi
}

add_domain_to_hostfile () {
  # handle if a domain was not configured
  if [ "$HOSTMAP" == "127.0.0.1 " ]; then
    message "Domain not found.\nPlease provide a custom domain in docker/.env.docker under the key:\nPWA_STUDIO_PUBLIC_PATH"
    exit 1
  fi
  
  if [ "$IS_WINDOWS_MACHINE" == "y" ]; then
    add_domain_to_hostfile_windows
  else 
    add_domain_to_hostfile_nix
  fi
}

# Windows specific manual host file editing instructions
add_domain_to_hostfile_windows () {
  echo "================================================================================="
  echo "In order to setup the hostmapping correctly, follow the below steps:"
  echo "Open the command prompt (CMD) in administrative mode."
  echo "Run the following command to edit the host file:"
  echo "notepad C:\Windows\System32\drivers\etc\hosts"
  echo "Add the following to the end of the file and save:"
  echo "$HOSTMAP"
  echo "================================================================================="
  read -p "Have you completed the above steps? [y/n] " EDITED_HOSTFILE
}

# *nix specific manual host file editing automation
add_domain_to_hostfile_nix () {
  HOSTSFILE=/etc/hosts
  HOSTPRESENT=false

  # check to see if the hostfile already contains the hostmap/domain
  while read -r var; do 
    if [ "$var" == "$HOSTMAP" ]; then
      HOSTPRESENT=true
    fi
  done < $HOSTSFILE

  # add the domain if it is not present in the hostfile, otherwise don't
  if [ "$HOSTPRESENT" == false ]; then
    message "Please provide your password, if requested, to modify $HOSTSFILE"
    echo $HOSTMAP | sudo tee -a $HOSTSFILE

    # handle error with adding to the hostfile
    if [ $? == 0 ]; then
      message "Added $HOSTMAP configured in $ENVFILE to $HOSTSFILE"
      EDITED_HOSTFILE="y"
    else 
      message "Host was not added to $HOSTSFILE.\nPlease enter your password to add $HOSTMAP to your hostsfile."
    fi
  else 
    message "$HOSTSFILE already configured with $HOSTMAP"
    EDITED_HOSTFILE="y"
  fi
}

generate_certificate () {
  # make docker/certs folder if one does not already exist
  [ -d ./docker/certs ] || mkdir ./docker/certs

  # generate a new self-signed certificate if one does not already exist for $DOMAIN
  if [ -f ./docker/certs/$DOMAIN.crt ]; then
    message "SSL certificate for $DOMAIN found.\nIf you experience issues remove the certificate in\n./docker/certs/$DOMAIN.crt and rerun script."
    CERT_TRUSTED="y"
    return
  else
    message "Generating SSL certificate.\nProvide credentials, if requested, to trust the certificate."
  fi

  # generate an openssl config for creating a certificate signing request (CSR)
  OpenSSLConf=./docker/certs/"$DOMAIN"-openssl.cnf

  cat >$OpenSSLConf <<EOL
[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no
[req_distinguished_name]
CN = $DOMAIN
[v3_req]
keyUsage = keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = *.$DOMAIN
DNS.2 = $DOMAIN
EOL

  # create key (no passphrase), CSR, and SSL certificate
  openssl req \
  -new \
  -newkey rsa:2048 \
  -sha1 \
  -days 3650 \
  -nodes \
  -x509 \
  -keyout ./docker/certs/$DOMAIN.key \
  -out ./docker/certs/$DOMAIN.crt \
  -config $OpenSSLConf

  if [ "$IS_WINDOWS_MACHINE" == "y" ]; then
    trust_certificate_windows
  else
    trust_certificate_nix
  fi
}

trust_certificate_windows () {
  echo "================================================================================="
  echo "In order to trust the SSL certificate for https support, follow the below steps:"
  echo "Open the certificate folder in Explorer, found in ./docker/certs"
  echo "Double click on the certificate, named: $DOMAIN.crt"
  echo "Install certificate..."
  echo "Choose Local Machine"
  echo "Choose Place all certificates in the following store and click Browse..."
  echo "Choose Trusted Root Certification Authorities and click OK."
  echo "Click Next, then Finish."
  echo "Your certificate is now trusted"
  echo "================================================================================="
  read -p "Have you completed the steps above to trust the certificate? [y/n] " CERT_TRUSTED
}

trust_certificate_nix () {
  # add the certificate to the system keychain and trust the certificate
  sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain ./docker/certs/$DOMAIN.crt

  if [ $? == 0 ]; then
    message "Certificate generated and trusted by system successfully."
    CERT_TRUSTED="y"
  else 
    message "Error occurred during certificate generation/trust.\nPlease enter your password to trust the certificate."
  fi
}

start_docker () {
  message "Clearing any running containers"
  docker-compose down

  message "Building PWA image"
  BUILD_STATUS=0
  docker-compose build || BUILD_STATUS=$?

  # clean up the environment in the background
  clean_up_env &
  
  if [ "$BUILD_STATUS" == 0 ]; then
    message "Starting Docker network and containers"
    docker-compose up
  else
    message "Build failed. See output for details."
  fi
}

clean_up_env () {
  # the docker-compose command needs the .env file to be present in order to run
  # but we want to remove it after execution so it doesn't pollute the user's environment 
  # when they switch to other branches or do not want to use the docker environment anymore
  if [ -f .env ]; then
    sleep 20
    rm .env
  fi
}

message () {
  echo ""
  echo "==========================================================================="
  echo ""
  echo -e "        " "$1"
  echo ""
  echo "==========================================================================="
  echo ""
}

main 
