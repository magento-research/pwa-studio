#!/usr/bin/env bash

####################################################################################
#
#   Run this file from the root of the repository to build and run a PWA container
#
####################################################################################
EDITED_HOSTFILE="n"
CERT_TRUSTED="n"

main () {
  # capture whether the user is on a Windows machine for separate setup tasks
  read -p "Are you on a Windows machine? [y/n] " IS_WINDOWS_MACHINE

  # copy environment variables to .env in root for docker-compose to consume for build
  message "Adding environment variables in root .env for docker setup."
  ENVFILE=./.env
  cp ./docker/.env.docker $ENVFILE 
  . $ENVFILE

  DOMAIN=$PWA_STUDIO_PUBLIC_PATH
  HOSTMAP="127.0.0.1 $DOMAIN"

  add_domain_to_hostfile

  generate_certificate

  if [ "$EDITED_HOSTFILE" == "y" ] && [ "$CERT_TRUSTED" == "y" ]; then
    start_docker
  else
    message "The host file does not include your domain and/or the certificate is not trusted.\nPlease follow the steps to edit your system host file and trust the ssl certificate.\nThe application will not run correctly without completing these steps."
    rm ./docker/certs/$DOMAIN.crt
    exit 1
  fi
}

add_domain_to_hostfile () {
  # handle if a domain was not configured
  if [ "$HOSTMAP" == "127.0.0.1 " ]; then
    message "Domain not found.\nPlease provide a custom domain in docker/.env.docker under the key:\nPWA_STUDIO_PUBLIC_PATH"
    exit 1
  fi
  
  # Windows specific manual host file editing instructions
  if [ "$IS_WINDOWS_MACHINE" == "y" ]; then
    echo "================================================================================="
    echo "In order to setup the hostmapping correctly, follow the below steps:"
    echo "Open the command prompt (CMD) in administrative mode."
    echo "Run the following command to edit the host file:"
    echo "notepad C:\Windows\System32\drivers\etc\hosts"
    echo "Add the following to the end of the file and save:"
    echo "$HOSTMAP"
    echo "================================================================================="
    read -p "Have you completed the above steps? [y/n] " EDITED_HOSTFILE
  else 
    # Automated Mac OS host file editing

    HOSTSFILE=/etc/hosts
    HOSTPRESENT=false

    # check to see if the hostfile already contains the hostmap/domain
    while read -r var; do 
      if [ "$var" == "$HOSTMAP" ]; then
        HOSTPRESENT=true
      fi
    done < $HOSTSFILE

    # add the domain if it is not present in the hostfile, otherwise don't
    if [ "$HOSTPRESENT" == false ]; then
      message "Please provide your password, if requested, to modify $HOSTSFILE"
      echo $HOSTMAP | sudo tee -a $HOSTSFILE

      # handle error with adding to the hostfile
      if [ $? == 0 ]; then
        message "Added $HOSTMAP configured in $ENVFILE to $HOSTSFILE"
        EDITED_HOSTFILE="y"
      else 
        message "Host was not added to $HOSTSFILE.\nPlease enter your password to add $HOSTMAP to your hostsfile."
      fi
    else 
      message "$HOSTSFILE already configured with $HOSTMAP"
      EDITED_HOSTFILE="y"
    fi
  fi
}

generate_certificate () {
  # make docker/certs folder if one does not already exist
  [ -d ./docker/certs ] || mkdir ./docker/certs

  # generate a new self-signed certificate if one does not already exist for $DOMAIN
  if [ -f ./docker/certs/$DOMAIN.crt ]; then
    message "SSL certificate for $DOMAIN found.\nIf you experience issues remove the certificate in\n./docker/certs/$DOMAIN.crt and rerun script."
    CERT_TRUSTED="y"
    return
  else
    message "Generating SSL certificate.\nProvide credentials, if requested, to trust the certificate."
  fi

  # generate an openssl config for creating a certificate signing request (CSR)
  OpenSSLConf=./docker/certs/"$DOMAIN"-openssl.cnf

  cat >$OpenSSLConf <<EOL
[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no
[req_distinguished_name]
CN = $DOMAIN
[v3_req]
keyUsage = keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = *.$DOMAIN
DNS.2 = $DOMAIN
EOL

  # create key (no passphrase), CSR, and SSL certificate
  openssl req \
  -new \
  -newkey rsa:2048 \
  -sha1 \
  -days 3650 \
  -nodes \
  -x509 \
  -keyout ./docker/certs/$DOMAIN.key \
  -out ./docker/certs/$DOMAIN.crt \
  -config $OpenSSLConf

  if [ "$IS_WINDOWS_MACHINE" == "y" ]; then
    echo "================================================================================="
    echo "In order to trust the SSL certificate for https support, follow the below steps:"
    echo "Open the certificate folder in Explorer, found in ./docker/certs"
    echo "Double click on the certificate, named: $DOMAIN.crt"
    echo "Install certificate..."
    echo "Choose Local Machine"
    echo "Choose Place all certificates in the following store and click Browse..."
    echo "Choose Trusted Root Certification Authorities and click OK."
    echo "Click Next, then Finish."
    echo "Your certificate is now trusted"
    echo "================================================================================="
    read -p "Have you completed the steps above to trust the certificate? [y/n] " CERT_TRUSTED
  else
    # add the certificate to the system keychain and trust the certificate
    sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain ./docker/certs/$DOMAIN.crt

    if [ $? == 0 ]; then
      message "Certificate generated and trusted by system successfully."
      CERT_TRUSTED="y"
    else 
      message "Error occurred during certificate generation/trust.\nPlease enter your password to trust the certificate."
    fi
  fi
}

start_docker () {
  message "Clearing any running containers"
  docker-compose down

  message "Building PWA image"
  docker-compose build

  # clean up the environment in the background
  clean_up_env &

  message "Starting Docker network and containers"
  docker-compose up
}

clean_up_env () {
  # the docker-compose command needs the .env file to be present in order to run
  # but we want to remove it after execution so it doesn't pollute the user's environment 
  # when they switch to other branches or do not want to use the docker environment anymore
  if [ -f .env ]; then
    sleep 20
    rm .env
  fi
}

message () {
  echo ""
  echo "==========================================================================="
  echo ""
  echo -e "        " "$1"
  echo ""
  echo "==========================================================================="
  echo ""
}

main 
